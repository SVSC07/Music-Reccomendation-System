
"""Hindi_Songs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vz-PxU18rM9xGcURev2bBqExFa_I-kbJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics.pairwise import cosine_similarity

df = pd.read_csv("Hindi_songs.csv")
print(f"Original dataset shape: {df.shape}")
df = df.sample(n= 1000, random_state=42).reset_index(drop = True)
print(f"Sampled dataset shape: {df.shape}")
print("Dataset loaded successfully!")
print(f"Columns: {list(df.columns)}")
print("\nFirst few rows:")
print(df.head())

# Select relevant numerical features for clustering

numerical_features = [
    "Valence", "danceability", "energy", "tempo",
    "acousticness", "liveness", "speechiness"
]

# Standardize the numerical features
scaler = StandardScaler()
df_scaled = pd.DataFrame(scaler.fit_transform(df[numerical_features]), columns=numerical_features)

# Optional: Split for testing or validation

train_data, test_data = train_test_split(df_scaled, test_size=0.2, random_state=42)

#Elbow Method Plot
#To find optimal K

# Determine the optimal number of clusters using the Elbow Method
inertia = []
k_values = range(1, 11)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    # Drop rows with NaN values before fitting the model
    kmeans.fit(train_data.dropna())
    inertia.append(kmeans.inertia_)

# Plot the Elbow Method
plt.figure(figsize=(10, 6))
plt.plot(k_values, inertia, marker='o')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.title('Elbow Method for Optimal k')
plt.savefig('elbow_method_plot.png', dpi=300, bbox_inches='tight')
plt.show()
print("Elbow method plot saved as 'elbow_method_plot.png'")

# Applying KMeans
# Apply K-Means clustering with optimal k (e.g., k=4)
optimal_k = 4
kmeans = KMeans(n_clusters=optimal_k, random_state=42)

# Perform clustering on the scaled data after dropping NaNs
df_scaled_cleaned = df_scaled.dropna()
cluster_labels = kmeans.fit_predict(df_scaled_cleaned)

# Assign cluster labels to the original DataFrame, aligning by index
# Create a new column in the original DataFrame and initialize with NaN
df["Cluster"] = pd.NA

# Assign the cluster labels to the rows in df that correspond to the non-null rows in df_scaled
df.loc[df_scaled_cleaned.index, "Cluster"] = cluster_labels.astype(int)
print(f"Clustering completed with {optimal_k} clusters!")
print(f"Cluster distribution:")
print(df["Cluster"].value_counts().sort_index())


# Visualize clusters using PCA

pca = PCA(n_components=2)
pca_result = pca.fit_transform(df_scaled_cleaned)

# Drop rows with NA in the 'Cluster' column before plotting
df_plot = df.dropna(subset=["Cluster"])

plt.figure(figsize=(10,8))
plt.scatter(pca_result[:, 0], pca_result[:, 1], c=df_plot["Cluster"], cmap="viridis")
plt.title("K-Means Clusters")
plt.colorbar(label='Cluster')
plt.xlabel('First Principal Component')
plt.ylabel('Second Principal Component')
plt.savefig('kmeans_clusters_plot.png', dpi=300, bbox_inches='tight')
plt.show()
print("K-Means clusters plot saved as 'kmeans_clusters_plot.png'")



def recommend_songs(song_name, df, numerical_features, num_recommendations=5):
    # --- Validate required columns ---
    required_cols = {"song_name", "Cluster"}
    missing_cols = required_cols - set(df.columns)
    if missing_cols:
        raise KeyError(f"Missing columns in DataFrame: {missing_cols}. Available columns: {list(df.columns)}")

    # --- Check if input song exists ---
    if song_name not in df["song_name"].values:
        raise ValueError(f"Song '{song_name}' not found in dataset. Please check spelling or try another title.")

    # --- Get the cluster of the input song ---
    song_cluster = df.loc[df["song_name"] == song_name, "Cluster"].values[0]

    # --- Filter songs from the same cluster ---
    same_cluster_songs = df[df["Cluster"] == song_cluster].copy() # Use .copy() to avoid SettingWithCopyWarning

    # --- Ensure numerical features exist ---
    for feature in numerical_features:
        if feature not in same_cluster_songs.columns:
            raise KeyError(f"Feature '{feature}' not found in DataFrame.")

    # --- Calculate cosine similarity within the cluster ---
    # Get the index of the input song within the same_cluster_songs DataFrame
    song_index_in_cluster = same_cluster_songs[same_cluster_songs["song_name"] == song_name].index[0]

    cluster_features = same_cluster_songs[numerical_features]
    similarity = cosine_similarity(cluster_features, cluster_features)

    # --- Get top recommendations (excluding the same song) ---
    # Get the indices of similar songs within the similarity matrix
    similar_song_indices_in_cluster = np.argsort(similarity[same_cluster_songs.index.get_loc(song_index_in_cluster)])[-(num_recommendations + 1):-1][::-1]

    # Get the original indices of the recommended songs from same_cluster_songs
    recommended_songs_original_indices = same_cluster_songs.iloc[similar_song_indices_in_cluster].index

    recommendations = df.loc[recommended_songs_original_indices][["song_name", "released_date", "singer"]]

    return recommendations

# Example usage
# Define the song to search for
input_song = "Ek Ajnabee Haseena Se"

# Define which numerical features to use for similarity
numerical_features = ["danceability", "energy", "tempo", "Valence"]

# Get top 4 recommended songs
recommended_songs = recommend_songs(input_song, df, numerical_features, num_recommendations=5)

# Display results
print(f"Songs similar to '{input_song}':")
print(recommended_songs)

# Example usage
# Define the song to search for
input_song = "Chura Liya Hai Tumne Jo Dil Ko"

# Define which numerical features to use for similarity
numerical_features = ["danceability", "energy", "tempo", "Valence"]

# Get top 4 recommended songs
recommended_songs = recommend_songs(input_song, df, numerical_features, num_recommendations=5)

# Display results
print(f"Songs similar to '{input_song}':")
print(recommended_songs)

# save df
df.to_csv("clustered_df.csv")